{"version":3,"file":"lazyLoadNgModule.js","sourceRoot":"","sources":["../../src/lazyLoad/lazyLoadNgModule.ts"],"names":[],"mappings":"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","sourcesContent":["import { NgModuleRef, Injector, NgModuleFactory, Type, Compiler } from '@angular/core';\nimport {\n  Transition,\n  LazyLoadResult,\n  UIRouter,\n  Resolvable,\n  NATIVE_INJECTOR_TOKEN,\n  isString,\n  unnestR,\n  inArray,\n  StateObject,\n  uniqR,\n  StateDeclaration,\n} from '@uirouter/core';\nimport { UIROUTER_MODULE_TOKEN, UIROUTER_ROOT_MODULE } from '../injectionTokens';\nimport { RootModule, StatesModule } from '../uiRouterNgModule';\nimport { applyModuleConfig } from '../uiRouterConfig';\n\n/**\n * A function that returns an NgModule, or a promise for an NgModule\n *\n * #### Example:\n * ```js\n * export function loadFooModule() {\n *   return import('../foo/foo.module').then(result => result.FooModule);\n * }\n * ```\n */\nexport type ModuleTypeCallback = () => Type<any> | Promise<Type<any>>;\n\n/**\n * Returns a function which lazy loads a nested module\n *\n * This is primarily used by the [[ng2LazyLoadBuilder]] when processing [[Ng2StateDeclaration.loadChildren]].\n *\n * It could also be used manually as a [[StateDeclaration.lazyLoad]] property to lazy load an `NgModule` and its state(s).\n *\n * #### Example:\n * Using `import()` and named export of `HomeModule`\n * ```js\n * declare var System;\n * var futureState = {\n *   name: 'home.**',\n *   url: '/home',\n *   lazyLoad: loadNgModule(() => import('./home/home.module').then(result => result.HomeModule))\n * }\n * ```\n *\n * #### Example:\n * Using a path (string) to the module\n * ```js\n * var futureState = {\n *   name: 'home.**',\n *   url: '/home',\n *   lazyLoad: loadNgModule('./home/home.module#HomeModule')\n * }\n * ```\n *\n *\n * @param moduleToLoad a path (string) to the NgModule to load.\n *    Or a function which loads the NgModule code which should\n *    return a reference to  the `NgModule` class being loaded (or a `Promise` for it).\n *\n * @returns A function which takes a transition, which:\n * - Gets the Injector (scoped properly for the destination state)\n * - Loads and creates the NgModule\n * - Finds the \"replacement state\" for the target state, and adds the new NgModule Injector to it (as a resolve)\n * - Returns the new states array\n */\nexport function loadNgModule(\n  moduleToLoad: ModuleTypeCallback\n): (transition: Transition, stateObject: StateDeclaration) => Promise<LazyLoadResult> {\n  return (transition: Transition, stateObject: StateDeclaration) => {\n    const ng2Injector = transition.injector().get(NATIVE_INJECTOR_TOKEN);\n\n    const createModule = (factory: NgModuleFactory<any>) => factory.create(ng2Injector);\n\n    const applyModule = (moduleRef: NgModuleRef<any>) => applyNgModule(transition, moduleRef, ng2Injector, stateObject);\n\n    return loadModuleFactory(moduleToLoad, ng2Injector).then(createModule).then(applyModule);\n  };\n}\n\n/**\n * Returns the module factory that can be used to instantiate a module\n *\n * For a Type<any> or Promise<Type<any>> this:\n * - Compiles the component type (if not running with AOT)\n * - Returns the NgModuleFactory resulting from compilation (or direct loading if using AOT) as a Promise\n *\n * @internal\n */\nexport function loadModuleFactory(\n  moduleToLoad: ModuleTypeCallback,\n  ng2Injector: Injector\n): Promise<NgModuleFactory<any>> {\n  const compiler: Compiler = ng2Injector.get(Compiler);\n\n  const unwrapEsModuleDefault = (x) => (x && x.__esModule && x['default'] ? x['default'] : x);\n\n  return Promise.resolve(moduleToLoad())\n    .then(unwrapEsModuleDefault)\n    .then((t: NgModuleFactory<any> | Type<any>) => {\n      if (t instanceof NgModuleFactory) {\n        return t;\n      }\n      return compiler.compileModuleAsync(t);\n    });\n}\n\n/**\n * Apply the UI-Router Modules found in the lazy loaded module.\n *\n * Apply the Lazy Loaded NgModule's newly created Injector to the right state in the state tree.\n *\n * Lazy loading uses a placeholder state which is removed (and replaced) after the module is loaded.\n * The NgModule should include a state with the same name as the placeholder.\n *\n * Find the *newly loaded state* with the same name as the *placeholder state*.\n * The NgModule's Injector (and ComponentFactoryResolver) will be added to that state.\n * The Injector/Factory are used when creating Components for the `replacement` state and all its children.\n *\n * @internal\n */\nexport function applyNgModule(\n  transition: Transition,\n  ng2Module: NgModuleRef<any>,\n  parentInjector: Injector,\n  lazyLoadState: StateDeclaration\n): LazyLoadResult {\n  const injector = ng2Module.injector;\n  const uiRouter: UIRouter = injector.get(UIRouter);\n  const registry = uiRouter.stateRegistry;\n\n  const originalName = lazyLoadState.name;\n  const originalState = registry.get(originalName);\n  // Check if it's a future state (ends with .**)\n  const isFuture = /^(.*)\\.\\*\\*$/.exec(originalName);\n  // Final name (without the .**)\n  const replacementName = isFuture && isFuture[1];\n\n  const newRootModules = multiProviderParentChildDelta(parentInjector, injector, UIROUTER_ROOT_MODULE).reduce(\n    uniqR,\n    []\n  ) as RootModule[];\n  const newChildModules = multiProviderParentChildDelta(parentInjector, injector, UIROUTER_MODULE_TOKEN).reduce(\n    uniqR,\n    []\n  ) as StatesModule[];\n\n  if (newRootModules.length) {\n    console.log(newRootModules); // tslint:disable-line:no-console\n    throw new Error('Lazy loaded modules should not contain a UIRouterModule.forRoot() module');\n  }\n\n  const newStateObjects: StateObject[] = newChildModules\n    .map((module) => applyModuleConfig(uiRouter, injector, module))\n    .reduce(unnestR, [])\n    .reduce(uniqR, []);\n\n  if (isFuture) {\n    const replacementState = registry.get(replacementName);\n    if (!replacementState || replacementState === originalState) {\n      throw new Error(\n        `The Future State named '${originalName}' lazy loaded an NgModule. ` +\n          `The lazy loaded NgModule must have a state named '${replacementName}' ` +\n          `which replaces the (placeholder) '${originalName}' Future State. ` +\n          `Add a '${replacementName}' state to the lazy loaded NgModule ` +\n          `using UIRouterModule.forChild({ states: CHILD_STATES }).`\n      );\n    }\n  }\n\n  // Supply the newly loaded states with the Injector from the lazy loaded NgModule.\n  // If a tree of states is lazy loaded, only add the injector to the root of the lazy loaded tree.\n  // The children will get the injector by resolve inheritance.\n  const newParentStates = newStateObjects.filter((state) => !inArray(newStateObjects, state.parent));\n\n  // Add the Injector to the top of the lazy loaded state tree as a resolve\n  newParentStates.forEach((state) => state.resolvables.push(Resolvable.fromData(NATIVE_INJECTOR_TOKEN, injector)));\n\n  return {};\n}\n\n/**\n * Returns the new dependency injection values from the Child Injector\n *\n * When a DI token is defined as multi: true, the child injector\n * can add new values for the token.\n *\n * This function returns the values added by the child injector,  and excludes all values from the parent injector.\n *\n * @internal\n */\nexport function multiProviderParentChildDelta(parent: Injector, child: Injector, token: any) {\n  const childVals: RootModule[] = child.get(token, []);\n  const parentVals: RootModule[] = parent.get(token, []);\n  return childVals.filter((val) => parentVals.indexOf(val) === -1);\n}\n"]}