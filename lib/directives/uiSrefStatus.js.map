{"version":3,"file":"uiSrefStatus.js","sourceRoot":"","sources":["../../src/directives/uiSrefStatus.ts"],"names":[],"mappings":"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","sourcesContent":["import { Directive, Output, EventEmitter, ContentChildren, QueryList, Host, Self, Optional } from '@angular/core';\nimport { UISref } from './uiSref';\nimport {\n  PathNode,\n  Transition,\n  TargetState,\n  StateObject,\n  anyTrueR,\n  tail,\n  unnestR,\n  Predicate,\n  UIRouterGlobals,\n  Param,\n  PathUtils,\n  identity,\n  uniqR,\n} from '@uirouter/core';\n\nimport { Subscription, Observable, BehaviorSubject, of, from, combineLatest, concat } from 'rxjs';\nimport { switchMap, map, tap } from 'rxjs/operators';\n\n/** @internal */\ninterface TransEvt {\n  evt: string;\n  trans: Transition;\n}\n\n/**\n * UISref status emitted from [[UISrefStatus]]\n */\nexport interface SrefStatus {\n  /** The sref's target state (or one of its children) is currently active */\n  active: boolean;\n  /** The sref's target state is currently active */\n  exact: boolean;\n  /** A transition is entering the sref's target state */\n  entering: boolean;\n  /** A transition is exiting the sref's target state */\n  exiting: boolean;\n  /** The enclosed sref(s) target state(s) */\n  targetStates: TargetState[];\n}\n\n/** @internal */\nconst inactiveStatus: SrefStatus = {\n  active: false,\n  exact: false,\n  entering: false,\n  exiting: false,\n  targetStates: [],\n};\n\n/**\n * Returns a Predicate<PathNode[]>\n *\n * The predicate returns true when the target state (and param values)\n * match the (tail of) the path, and the path's param values\n *\n * @internal\n */\nconst pathMatches = (target: TargetState): Predicate<PathNode[]> => {\n  if (!target.exists()) return () => false;\n  const state: StateObject = target.$state();\n  const targetParamVals = target.params();\n  const targetPath: PathNode[] = PathUtils.buildPath(target);\n  const paramSchema: Param[] = targetPath\n    .map((node) => node.paramSchema)\n    .reduce(unnestR, [])\n    .filter((param: Param) => targetParamVals.hasOwnProperty(param.id));\n\n  return (path: PathNode[]) => {\n    const tailNode = tail(path);\n    if (!tailNode || tailNode.state !== state) return false;\n    const paramValues = PathUtils.paramValues(path);\n    return Param.equals(paramSchema, paramValues, targetParamVals);\n  };\n};\n\n/**\n * Given basePath: [a, b], appendPath: [c, d]),\n * Expands the path to [c], [c, d]\n * Then appends each to [a,b,] and returns: [a, b, c], [a, b, c, d]\n *\n * @internal\n */\nfunction spreadToSubPaths(basePath: PathNode[], appendPath: PathNode[]): PathNode[][] {\n  return appendPath.map((node) => basePath.concat(PathUtils.subPath(appendPath, (n) => n.state === node.state)));\n}\n\n/**\n * Given a TransEvt (Transition event: started, success, error)\n * and a UISref Target State, return a SrefStatus object\n * which represents the current status of that Sref:\n * active, activeEq (exact match), entering, exiting\n *\n * @internal\n */\nfunction getSrefStatus(event: TransEvt, srefTarget: TargetState): SrefStatus {\n  const pathMatchesTarget = pathMatches(srefTarget);\n  const tc = event.trans.treeChanges();\n\n  const isStartEvent = event.evt === 'start';\n  const isSuccessEvent = event.evt === 'success';\n  const activePath: PathNode[] = isSuccessEvent ? tc.to : tc.from;\n\n  const isActive = () => spreadToSubPaths([], activePath).map(pathMatchesTarget).reduce(anyTrueR, false);\n\n  const isExact = () => pathMatchesTarget(activePath);\n\n  const isEntering = () => spreadToSubPaths(tc.retained, tc.entering).map(pathMatchesTarget).reduce(anyTrueR, false);\n\n  const isExiting = () => spreadToSubPaths(tc.retained, tc.exiting).map(pathMatchesTarget).reduce(anyTrueR, false);\n\n  return {\n    active: isActive(),\n    exact: isExact(),\n    entering: isStartEvent ? isEntering() : false,\n    exiting: isStartEvent ? isExiting() : false,\n    targetStates: [srefTarget],\n  } as SrefStatus;\n}\n\n/** @internal */\nfunction mergeSrefStatus(left: SrefStatus, right: SrefStatus): SrefStatus {\n  return {\n    active: left.active || right.active,\n    exact: left.exact || right.exact,\n    entering: left.entering || right.entering,\n    exiting: left.exiting || right.exiting,\n    targetStates: left.targetStates.concat(right.targetStates),\n  };\n}\n\n/**\n * A directive which emits events when a paired [[UISref]] status changes.\n *\n * This directive is primarily used by the [[UISrefActive]] directives to monitor `UISref`(s).\n *\n * This directive shares two attribute selectors with `UISrefActive`:\n *\n * - `[uiSrefActive]`\n * - `[uiSrefActiveEq]`.\n *\n * Thus, whenever a `UISrefActive` directive is created, a `UISrefStatus` directive is also created.\n *\n * Most apps should simply use `UISrefActive`, but some advanced components may want to process the\n * [[SrefStatus]] events directly.\n *\n * ```js\n * <li (uiSrefStatus)=\"onSrefStatusChanged($event)\">\n *   <a uiSref=\"book\" [uiParams]=\"{ bookId: book.id }\">Book {{ book.name }}</a>\n * </li>\n * ```\n *\n * The `uiSrefStatus` event is emitted whenever an enclosed `uiSref`'s status changes.\n * The event emitted is of type [[SrefStatus]], and has boolean values for `active`, `exact`, `entering`, and `exiting`; also has a [[StateOrName]] `identifier`value.\n *\n * The values from this event can be captured and stored on a component (then applied, e.g., using ngClass).\n *\n * ---\n *\n * A single `uiSrefStatus` can enclose multiple `uiSref`.\n * Each status boolean (`active`, `exact`, `entering`, `exiting`) will be true if *any of the enclosed `uiSref` status is true*.\n * In other words, all enclosed `uiSref` statuses  are merged to a single status using `||` (logical or).\n *\n * ```js\n * <li (uiSrefStatus)=\"onSrefStatus($event)\" uiSref=\"admin\">\n *   Home\n *   <ul>\n *     <li> <a uiSref=\"admin.users\">Users</a> </li>\n *     <li> <a uiSref=\"admin.groups\">Groups</a> </li>\n *   </ul>\n * </li>\n * ```\n *\n * In the above example, `$event.active === true` when either `admin.users` or `admin.groups` is active.\n *\n * ---\n *\n * This API is subject to change.\n */\n@Directive({\n  selector: '[uiSrefStatus],[uiSrefActive],[uiSrefActiveEq]',\n  exportAs: 'uiSrefStatus',\n})\nexport class UISrefStatus {\n  /** current statuses of the state/params the uiSref directive is linking to */\n  @Output('uiSrefStatus') uiSrefStatus = new EventEmitter<SrefStatus>(false);\n  /** Monitor all child components for UISref(s) */\n  @ContentChildren(UISref, { descendants: true })\n  private _srefs: QueryList<UISref>;\n\n  /** The current status */\n  status: SrefStatus;\n\n  /** @internal */ private _subscription: Subscription;\n  /** @internal */ private _srefChangesSub: Subscription;\n  /** @internal */ private _srefs$: BehaviorSubject<UISref[]>;\n  /** @internal */ private _globals: UIRouterGlobals;\n  /** @internal */ private _hostUiSref: UISref;\n  constructor(@Host() @Self() @Optional() _hostUiSref: UISref, _globals: UIRouterGlobals) {\n    this._globals = _globals;\n    this._hostUiSref = _hostUiSref;\n    this.status = Object.assign({}, inactiveStatus);\n  }\n\n  ngAfterContentInit() {\n    // Map each transition start event to a stream of:\n    // start -> (success|error)\n    const transEvents$: Observable<TransEvt> = this._globals.start$.pipe(\n      switchMap((trans: Transition) => {\n        const event = (evt: string) => ({ evt, trans } as TransEvt);\n\n        const transStart$ = of(event('start'));\n        const transResult = trans.promise.then(\n          () => event('success'),\n          () => event('error')\n        );\n        const transFinish$ = from(transResult);\n\n        return concat(transStart$, transFinish$);\n      })\n    );\n\n    const withHostSref = (childrenSrefs: UISref[]) =>\n      childrenSrefs.concat(this._hostUiSref).filter(identity).reduce(uniqR, []);\n\n    // Watch the @ContentChildren UISref[] components and get their target states\n    this._srefs$ = new BehaviorSubject(withHostSref(this._srefs.toArray()));\n    this._srefChangesSub = this._srefs.changes.subscribe((srefs: QueryList<UISref>) =>\n      this._srefs$.next(withHostSref(srefs.toArray()))\n    );\n\n    const targetStates$: Observable<TargetState[]> = this._srefs$.pipe(\n      switchMap((srefs: UISref[]) => combineLatest<TargetState[]>(srefs.map((sref) => sref.targetState$)))\n    );\n\n    // Calculate the status of each UISref based on the transition event.\n    // Reduce the statuses (if multiple) by or-ing each flag.\n    this._subscription = transEvents$\n      .pipe(\n        switchMap((evt: TransEvt) => {\n          return targetStates$.pipe(\n            map((targets: TargetState[]) => {\n              const statuses: SrefStatus[] = targets.map((target) => getSrefStatus(evt, target));\n              return statuses.reduce(mergeSrefStatus);\n            })\n          );\n        })\n      )\n      .subscribe(this._setStatus.bind(this));\n  }\n\n  ngOnDestroy() {\n    if (this._subscription) this._subscription.unsubscribe();\n    if (this._srefChangesSub) this._srefChangesSub.unsubscribe();\n    if (this._srefs$) this._srefs$.unsubscribe();\n    this._subscription = this._srefChangesSub = this._srefs$ = undefined;\n  }\n\n  private _setStatus(status: SrefStatus) {\n    this.status = status;\n    this.uiSrefStatus.emit(status);\n  }\n}\n"]}